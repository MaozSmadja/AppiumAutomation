'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumSupport = require('appium-support');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var log = _appiumSupport.logger.getLogger('simctl');

// https://regex101.com/r/UykjQZ/1
var IOS_RUNTIME_REGEXP = /iOS (\d+\.\d+) \((\d+\.\d+\.*\d*)/;

/**
 * Execute the particular simctl command and return the output.
 *
 * @param {string} command - One of available simctl subcommands.
 *                           Execute `xcrun simctl` in Terminal to see the full list
 *                           of available subcommands.
 * @param {number} timeout - Command execution timeout in milliseconds.
 *                           Set it to zero to skip waiting for command
 *                           execution.
 * @param {Array.<string>} args [[]] - The list of additional subcommand arguments.
 *                                     It's empty by default.
 * @param {Object} env [{}] - Environment variables mapping. All these variables
 *                            will be passed Simulator and used in _executingFunction_.
 * @param {Function} executingFunction - Executing function object. Equals to teen_process's
 *                                       _exec_ by default.
 * @param {boolean} logErrors [true] - Set it to _false_ to throw execution errors
 *                                     immediately without logging any additional information.
 * @return {Object} The result of _executingFunction_.
 * @throws {Error} If the simctl subcommand command executed by _executingFunction_
 *                 returns non-zero return code.
 */
function simCommand(command, timeout) {
  var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var env = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  var executingFunction = arguments.length <= 4 || arguments[4] === undefined ? _teen_process.exec : arguments[4];
  var logErrors = arguments.length <= 5 || arguments[5] === undefined ? true : arguments[5];
  return _regeneratorRuntime.async(function simCommand$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // run a particular simctl command
        args = ['simctl', command].concat(_toConsumableArray(args));
        // Prefix all passed in environment variables with 'SIMCTL_CHILD_', simctl
        // will then pass these to the child (spawned) process.
        env = _lodash2['default'].defaults(_lodash2['default'].mapKeys(env, function (value, key) {
          return 'SIMCTL_CHILD_' + key;
        }), process.env);

        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(executingFunction('xcrun', args, { timeout: timeout, env: env }));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](2);

        if (logErrors) {
          context$1$0.next = 14;
          break;
        }

        throw context$1$0.t0;

      case 14:
        if (context$1$0.t0.stderr) {
          log.errorAndThrow('simctl error running \'' + command + '\': ' + context$1$0.t0.stderr.trim());
        } else {
          log.errorAndThrow(context$1$0.t0);
        }

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 8]]);
}

/**
 * @typedef {Object} ExecResult
 * @property {?string} stdout - Process stdout.
 * @property {?string} stderr - Process stderr.
 * @property {number} code - Process exit code.
 */

/**
 * Execute the particular simctl subcommand synchronously and
 * wait for the output.
 *
 * @param {string} command - See {@link simCommand} parameters.
 * @param {number} timeout - See {@link simCommand} parameters.
 * @param {Array.<string>} args [[]] - See {@link simCommand} parameters.
 * @param {Object} env [{}] - See {@link simCommand} parameters.
 * @param {boolean} logErrors [true] - See {@link simCommand} parameters.
 * @return {ExecResult} The result of _exec_ function.
 * @throws {Error} If the simctl subcommand command executed by exec
 *                 returns non-zero return code.
 */
function simExec(command, timeout) {
  var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var env = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  var logErrors = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];
  return _regeneratorRuntime.async(function simExec$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simCommand(command, timeout, args, env, function callee$1$0(c, a, ob) {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(c, a, ob));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, logErrors));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Crate a teen_process's SubProcess instance for the particular
 * simctl subcommand execution. This might be needed to gain better
 * control over the execution process.
 *
 * @param {string} command - See {@link simCommand} parameters.
 * @param {number} timeout - See {@link simCommand} parameters.
 * @param {Array.<string>} args [[]] - See {@link simCommand} parameters.
 * @param {Object} env [{}] - See {@link simCommand} parameters.
 * @return {SubProcess} The instance of teen_process's SubProcess class.
 */
function simSubProcess(command, timeout) {
  var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var env = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  return _regeneratorRuntime.async(function simSubProcess$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simCommand(command, timeout, args, env, function callee$1$0(c, a, ob) {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                return context$2$0.abrupt('return', new _teen_process.SubProcess(c, a, ob));

              case 1:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Install the particular application package on Simulator.
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} appPath - Full path to .app package, which is
 *                           going to be installed.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function installApp(udid, appPath) {
  return _regeneratorRuntime.async(function installApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('install', 0, [udid, appPath]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Boot the particular Simulator if it is not running.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function bootDevice(udid) {
  return _regeneratorRuntime.async(function bootDevice$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(simExec('boot', 0, [udid]));

      case 3:
        context$1$0.next = 10;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!((context$1$0.t0.message || '').indexOf('Unable to boot device in current state: Booted') === -1)) {
          context$1$0.next = 9;
          break;
        }

        throw context$1$0.t0;

      case 9:
        log.debug('Simulator already in \'Booted\' state. Continuing');

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

/**
 * Remove the particular application package from Simulator.
 * It is required that Simulator is in _booted_ state and
 * the application with given bundle identifier is already installed.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} bundleId - Bundle identifier of the application,
 *                            which is going to be removed.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function removeApp(udid, bundleId) {
  return _regeneratorRuntime.async(function removeApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('uninstall', 0, [udid, bundleId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Execute the particular application package on Simulator.
 * It is required that Simulator is in _booted_ state and
 * the application with given bundle identifier is already installed.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} bundleId - Bundle identifier of the application,
 *                            which is going to be removed.
 * @param {number} tries [5] - The maximum number of retries before
 *                             throwing an exception.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function launch(udid, bundleId) {
  var tries = arguments.length <= 2 || arguments[2] === undefined ? 5 : arguments[2];
  return _regeneratorRuntime.async(function launch$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(tries, 1000, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(simExec('launch', 0, [udid, bundleId]));

              case 2:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3);
        }));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Spawn the particular process on Simulator.
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} executablePath - The path to the process on
 *                                  internal Simulator file system.
 * @param {object} env [{}] - Additional environment variables mapping.
 * @return {ExecResult} Command execution result.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function spawn(udid, executablePath) {
  var env = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _regeneratorRuntime.async(function spawn$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('spawn', 0, [udid, executablePath], env));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Prepare SubProcess instance for a new process, which is going to be spawned
 * on Simulator.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} executablePath - The path to the process on
 *                                  internal Simulator file system.
 * @param {object} env [{}] - Additional environment variables mapping.
 * @return {SubProcess} The instance of the process to be spawned.
 */
function spawnSubProcess(udid, executablePath) {
  var env = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _regeneratorRuntime.async(function spawnSubProcess$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simSubProcess('spawn', 0, [udid, executablePath], env));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Open URL scheme on Simulator. iOS will automatically try
 * to find a matching application, which supports the given scheme.
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} url - The URL scheme to open, for example http://appiom.io
 *                       will be opened by the built-in mobile browser.
 * @return {ExecResult} Command execution result.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function openUrl(udid, url) {
  return _regeneratorRuntime.async(function openUrl$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('openurl', 0, [udid, url]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Invoke hidden appinfo subcommand to get the information
 * about applications installed on Simulator, including
 * system applications ({@link getAppContainer} does not "see" such apps).
 * Simulator server should be in 'booted' state for this call to work properly.
 * The tool is only available since Xcode SDK 8.1
 *
 * @param {string} udid - UDID of the target Simulator.
 * @param {string} bundleId - The bundle identifier of the target application.
 * @return {string} The information about installed application.
 *
 * Example output for non-existing application container:
 * <pre>
 * {
 *   CFBundleIdentifier = "com.apple.MobileSafari";
 *   GroupContainers =     {
 *   };
 *   SBAppTags =     (
 *   );
 * }
 * </pre>
 *
 * Example output for an existing system application container:
 * <pre>
 * {
 *   ApplicationType = Hidden;
 *   Bundle = "file:///Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/CoreServices/SpringBoard.app";
 *   CFBundleDisplayName = SpringBoard;
 *   CFBundleExecutable = SpringBoard;
 *   CFBundleIdentifier = "com.apple.springboard";
 *   CFBundleName = SpringBoard;
 *   CFBundleVersion = 50;
 *   GroupContainers =     {
 *   };
 *   Path = "/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/CoreServices/SpringBoard.app";
 *   SBAppTags =     (
 *   );
 * }
 * </pre>
 */
function appInfo(udid, bundleId) {
  var _ref, stdout;

  return _regeneratorRuntime.async(function appInfo$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('appinfo', 0, [udid, bundleId]));

      case 2:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        return context$1$0.abrupt('return', (stdout || '').trim());

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Add the particular media file to Simulator's library.
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} path - Full path to a media file on the local
 *                        file system.
 * @return {ExecResult} Command execution result.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function addMedia(udid, path) {
  return _regeneratorRuntime.async(function addMedia$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('addmedia', 0, [udid, path]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Terminate the given running application on Simulator.
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} bundleId - Bundle identifier of the application,
 *                            which is going to be terminated.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function terminate(udid, bundleId) {
  return _regeneratorRuntime.async(function terminate$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('terminate', 0, [udid, bundleId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Get the full path to the particular application container
 * on the local file system. Note, that this subcommand throws
 * an error if bundle id of a system application is provided,
 * like 'com.apple.springboard'.
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {string} bundleId - Bundle identifier of an application.
 * @param {?boolean} logErrors [true] - Whether to include exec's command
 *                                      stderr output into exception message if thrown.
 * @param {?string} containerType - Which container type to return. Possible values
 *                                  are 'app', 'data', 'groups', '<A specific App Group container>'.
 *                                  The default value is 'app'.
 * @return {string} Full path to the given application container on the local
 *                  file system.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function getAppContainer(udid, bundleId) {
  var logErrors = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
  var containerType = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

  var args, _ref2, stdout;

  return _regeneratorRuntime.async(function getAppContainer$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = [udid, bundleId];

        if (containerType) {
          args.push(containerType);
        }
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(simExec('get_app_container', 0, args, {}, logErrors));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        return context$1$0.abrupt('return', (stdout || '').trim());

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Shutdown the given Simulator if it is running.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function shutdown(udid) {
  return _regeneratorRuntime.async(function shutdown$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(simExec('shutdown', 0, [udid]));

      case 3:
        context$1$0.next = 10;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if ((context$1$0.t0 + '').includes('current state: Shutdown')) {
          context$1$0.next = 9;
          break;
        }

        throw context$1$0.t0;

      case 9:
        log.debug('Simulator already in \'Shutdown\' state. Continuing');

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

/**
 * Create Simulator device with given name for the particular
 * platform type and version.
 *
 * @param {string} name - The device name to be created.
 * @param {string} deviceTypeId - Device type, for example 'iPhone 6'.
 * @param {string} runtimeId - Platform version, for example '10.3'.
 * @param {number} timeout [10000] - The maximum number of milliseconds to wait
 *                                   unit device creation is completed.
 * @return {string} The UDID of the newly created device.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function createDevice(name, deviceTypeId, runtimeId) {
  var timeout = arguments.length <= 3 || arguments[3] === undefined ? 10000 : arguments[3];
  var udid, out, reason, retries;
  return _regeneratorRuntime.async(function createDevice$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        udid = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(getRuntimeForPlatformVersion(runtimeId));

      case 4:
        runtimeId = context$1$0.sent;
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        log.warn('Unable to find runtime for iOS \'' + runtimeId + '\'. Continuing');

      case 10:

        log.debug('Creating simulator with name \'' + name + '\', device type id \'' + deviceTypeId + '\' and runtime id \'' + runtimeId + '\'');
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(simExec('create', 0, [name, deviceTypeId, runtimeId]));

      case 14:
        out = context$1$0.sent;

        udid = out.stdout.trim();
        context$1$0.next = 23;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t1 = context$1$0['catch'](11);
        reason = context$1$0.t1.message;

        if (context$1$0.t1.stderr) {
          reason = context$1$0.t1.stderr.trim();
        }
        log.errorAndThrow('Could not create simulator with name \'' + name + '\', device ' + ('type id \'' + deviceTypeId + '\' and runtime id \'' + runtimeId + '\'. Reason: \'' + reason + '\''));

      case 23:
        retries = parseInt(timeout / 1000, 10);
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 1000, function callee$1$0() {
          var devices, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, deviceArr, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, device;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(getDevices());

              case 2:
                devices = context$2$0.sent;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 6;
                _iterator = _getIterator(_lodash2['default'].values(devices));

              case 8:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$2$0.next = 43;
                  break;
                }

                deviceArr = _step.value;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$2$0.prev = 13;
                _iterator2 = _getIterator(deviceArr);

              case 15:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  context$2$0.next = 26;
                  break;
                }

                device = _step2.value;

                if (!(device.udid === udid)) {
                  context$2$0.next = 23;
                  break;
                }

                if (!(device.state === 'Creating')) {
                  context$2$0.next = 22;
                  break;
                }

                throw new Error('Device still being created');

              case 22:
                return context$2$0.abrupt('return');

              case 23:
                _iteratorNormalCompletion2 = true;
                context$2$0.next = 15;
                break;

              case 26:
                context$2$0.next = 32;
                break;

              case 28:
                context$2$0.prev = 28;
                context$2$0.t0 = context$2$0['catch'](13);
                _didIteratorError2 = true;
                _iteratorError2 = context$2$0.t0;

              case 32:
                context$2$0.prev = 32;
                context$2$0.prev = 33;

                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }

              case 35:
                context$2$0.prev = 35;

                if (!_didIteratorError2) {
                  context$2$0.next = 38;
                  break;
                }

                throw _iteratorError2;

              case 38:
                return context$2$0.finish(35);

              case 39:
                return context$2$0.finish(32);

              case 40:
                _iteratorNormalCompletion = true;
                context$2$0.next = 8;
                break;

              case 43:
                context$2$0.next = 49;
                break;

              case 45:
                context$2$0.prev = 45;
                context$2$0.t1 = context$2$0['catch'](6);
                _didIteratorError = true;
                _iteratorError = context$2$0.t1;

              case 49:
                context$2$0.prev = 49;
                context$2$0.prev = 50;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 52:
                context$2$0.prev = 52;

                if (!_didIteratorError) {
                  context$2$0.next = 55;
                  break;
                }

                throw _iteratorError;

              case 55:
                return context$2$0.finish(52);

              case 56:
                return context$2$0.finish(49);

              case 57:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4, [[6, 45, 49, 57], [13, 28, 32, 40], [33,, 35, 39], [50,, 52, 56]]);
        }));

      case 26:
        return context$1$0.abrupt('return', udid);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7], [11, 18]]);
}

/**
 * Delete the particular Simulator from available devices list.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function deleteDevice(udid) {
  return _regeneratorRuntime.async(function deleteDevice$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('delete', 0, [udid]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Reset the content and settings of the particular Simulator.
 * It is required that Simulator is in _shutdown_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @param {number} timeout [10000] - The maximum number of milliseconds to wait
 *                                   unit device reset is completed.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function eraseDevice(udid) {
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? 1000 : arguments[1];
  var loopFn, retries;
  return _regeneratorRuntime.async(function eraseDevice$(context$1$0) {
    var _this5 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        loopFn = function loopFn() {
          return _regeneratorRuntime.async(function loopFn$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(simExec('erase', 10000, [udid]));

              case 2:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this5);
        };

        retries = parseInt(timeout / 200, 10);
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 200, loopFn));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * @typedef {Object} DeviceInfo
 * @property {string} name - The device name.
 * @property {string} udid - The device UDID.
 * @property {string} state - The current Simulator state, for example 'booted' or 'shutdown'.
 * @property {string} sdk - The SDK version, for example '10.3'.
 */

/**
 * Parse the list of existing Simulator devices to represent
 * it as convenient mapping.
 *
 * @return {Object} The resulting mapping. Each key is platform version,
 *                  for example '10.3' and the corresponding value is an
 *                  array of the matching {@link DeviceInfo} instances.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function getDevicesByParsing() {
  var _ref3,
  // get the list of devices
  stdout, deviceSectionRe, matches, match, devices, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, sdk, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, line, lineRe, lineMatch;

  return _regeneratorRuntime.async(function getDevicesByParsing$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('list', 0, ['devices']));

      case 2:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;
        deviceSectionRe = /-- iOS (.+) --(\n\s{4}.+)*/mg;
        matches = [];
        match = deviceSectionRe.exec(stdout);

        // make an entry for each sdk version
        while (match !== null) {
          matches.push(match);
          match = deviceSectionRe.exec(stdout);
        }
        if (matches.length < 1) {
          log.errorAndThrow('Could not find device section');
        }

        // get all the devices for each sdk
        devices = {};
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 13;
        _iterator3 = _getIterator(matches);

      case 15:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 51;
          break;
        }

        match = _step3.value;
        sdk = match[1];

        devices[sdk] = [];
        // split the full match into lines and remove the first
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 22;
        _iterator4 = _getIterator(match[0].split('\n').slice(1));

      case 24:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 34;
          break;
        }

        line = _step4.value;
        lineRe = /([^\s].+) \((\w+-.+\w+)\) \((\w+\s?\w+)\)/;
        lineMatch = lineRe.exec(line);

        if (!(lineMatch === null)) {
          context$1$0.next = 30;
          break;
        }

        throw new Error('Could not match line: ' + line);

      case 30:
        // save the whole thing as ab object in the list for this sdk

        devices[sdk].push({
          name: lineMatch[1],
          udid: lineMatch[2],
          state: lineMatch[3],
          sdk: sdk
        });

      case 31:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 24;
        break;

      case 34:
        context$1$0.next = 40;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t0 = context$1$0['catch'](22);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 40:
        context$1$0.prev = 40;
        context$1$0.prev = 41;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 43:
        context$1$0.prev = 43;

        if (!_didIteratorError4) {
          context$1$0.next = 46;
          break;
        }

        throw _iteratorError4;

      case 46:
        return context$1$0.finish(43);

      case 47:
        return context$1$0.finish(40);

      case 48:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 15;
        break;

      case 51:
        context$1$0.next = 57;
        break;

      case 53:
        context$1$0.prev = 53;
        context$1$0.t1 = context$1$0['catch'](13);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t1;

      case 57:
        context$1$0.prev = 57;
        context$1$0.prev = 58;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 60:
        context$1$0.prev = 60;

        if (!_didIteratorError3) {
          context$1$0.next = 63;
          break;
        }

        throw _iteratorError3;

      case 63:
        return context$1$0.finish(60);

      case 64:
        return context$1$0.finish(57);

      case 65:
        return context$1$0.abrupt('return', devices);

      case 66:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[13, 53, 57, 65], [22, 36, 40, 48], [41,, 43, 47], [58,, 60, 64]]);
}

/**
 * Parse the list of existing Simulator devices to represent
 * it as convenient mapping for the particular platform version.
 *
 * @param {string} forSdk [null] - The platform version,
 *                                 for which the devices list should be parsed,
 *                                 for example '10.3'.
 * @return {Object|Array<DeviceInfo>} If _forSdk_ is set then the list
 *                                    of devices for the particular platform version.
 *                                    Otherwise the same result as for {@link getDevicesByParsing}
 *                                    function.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code or if no matching
 *                 platform version is found in the system.
 */
function getDevices() {
  var forSdk = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  var devices, _ref4, stdout, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _loop, _iterator5, _step5, _ret, errMsg, availableSDKs;

  return _regeneratorRuntime.async(function getDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        devices = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(simExec('list', 0, ['devices', '-j']));

      case 4:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;

        /* JSON should be
         * {
         *   "devices" : {
         *     "iOS <sdk>" : [
         *       {
         *         "state" : "Booted",
         *         "availability" : "(available)",
         *         "name" : "iPhone 6",
         *         "udid" : "75E34140-18E8-4D1A-9F45-AAC735DF75DF"
         *       }
         *     ]
         *   }
         * }
         */
        devices = {};
        _iteratorNormalCompletion5 = true;
        _didIteratorError5 = false;
        _iteratorError5 = undefined;
        context$1$0.prev = 10;

        _loop = function () {
          var _step5$value = _slicedToArray(_step5.value, 2);

          var sdkName = _step5$value[0];
          var entries = _step5$value[1];

          if (sdkName.indexOf('iOS') !== 0) {
            return 'continue';
          }
          var sdk = sdkName.replace('iOS ', '');
          devices[sdk] = entries.map(function (el) {
            delete el.availability;
            return _extends({}, el, { sdk: sdk });
          });
        };

        _iterator5 = _getIterator(_lodash2['default'].toPairs(JSON.parse(stdout).devices));

      case 13:
        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
          context$1$0.next = 20;
          break;
        }

        _ret = _loop();

        if (!(_ret === 'continue')) {
          context$1$0.next = 17;
          break;
        }

        return context$1$0.abrupt('continue', 17);

      case 17:
        _iteratorNormalCompletion5 = true;
        context$1$0.next = 13;
        break;

      case 20:
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](10);
        _didIteratorError5 = true;
        _iteratorError5 = context$1$0.t0;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion5 && _iterator5['return']) {
          _iterator5['return']();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError5) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError5;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        context$1$0.next = 43;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t1 = context$1$0['catch'](1);

        log.debug('Unable to get JSON device list: ' + context$1$0.t1.message);
        log.debug('Falling back to manually parsing');
        context$1$0.next = 42;
        return _regeneratorRuntime.awrap(getDevicesByParsing());

      case 42:
        devices = context$1$0.sent;

      case 43:
        if (!forSdk) {
          context$1$0.next = 50;
          break;
        }

        if (devices[forSdk]) {
          context$1$0.next = 49;
          break;
        }

        errMsg = '\'' + forSdk + '\' does not exist in the list of simctl SDKs.';
        availableSDKs = _lodash2['default'].keys(devices);

        errMsg += availableSDKs.length ? ' Only the following Simulator SDK versions are available on your system: ' + availableSDKs.join(', ') : ' No Simulator SDK versions are available on your system. Please install some via Xcode preferences.';
        throw new Error(errMsg);

      case 49:
        return context$1$0.abrupt('return', devices[forSdk]);

      case 50:
        return context$1$0.abrupt('return', devices);

      case 51:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 36], [10, 22, 26, 34], [27,, 29, 33]]);
}

/**
 * Get the runtime for the particular platform version.
 *
 * @param {string} platformVersion - The platform version name,
 *                                   for example '10.3'.
 * @return {string} The corresponding runtime name for the given
 *                  platform version.
 */
function getRuntimeForPlatformVersion(platformVersion) {
  var _ref5,
  // let {stdout} = await exec('xcrun', ['simctl', 'list', 'runtimes']);
  stdout, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, line, match;

  return _regeneratorRuntime.async(function getRuntimeForPlatformVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(simExec('list', 0, ['runtimes']));

      case 3:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;
        _iteratorNormalCompletion6 = true;
        _didIteratorError6 = false;
        _iteratorError6 = undefined;
        context$1$0.prev = 8;
        _iterator6 = _getIterator(stdout.split('\n'));

      case 10:
        if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
          context$1$0.next = 19;
          break;
        }

        line = _step6.value;
        match = IOS_RUNTIME_REGEXP.exec(line);

        if (!match) {
          context$1$0.next = 16;
          break;
        }

        if (!(match[1] === platformVersion)) {
          context$1$0.next = 16;
          break;
        }

        return context$1$0.abrupt('return', match[2]);

      case 16:
        _iteratorNormalCompletion6 = true;
        context$1$0.next = 10;
        break;

      case 19:
        context$1$0.next = 25;
        break;

      case 21:
        context$1$0.prev = 21;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError6 = true;
        _iteratorError6 = context$1$0.t0;

      case 25:
        context$1$0.prev = 25;
        context$1$0.prev = 26;

        if (!_iteratorNormalCompletion6 && _iterator6['return']) {
          _iterator6['return']();
        }

      case 28:
        context$1$0.prev = 28;

        if (!_didIteratorError6) {
          context$1$0.next = 31;
          break;
        }

        throw _iteratorError6;

      case 31:
        return context$1$0.finish(28);

      case 32:
        return context$1$0.finish(25);

      case 33:
        context$1$0.next = 37;
        break;

      case 35:
        context$1$0.prev = 35;
        context$1$0.t1 = context$1$0['catch'](0);

      case 37:
        return context$1$0.abrupt('return', platformVersion);

      case 38:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 35], [8, 21, 25, 33], [26,, 28, 32]]);
}

/**
 * Gets base64 screenshot for device (xcode >= 8.1 only).
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - The UDID of an existing Simulator.
 * @return {string} Base64-encoded Simulator screenshot.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function getScreenshot(udid) {
  var pathToScreenshotPng, screenshotImg;
  return _regeneratorRuntime.async(function getScreenshot$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'screenshot-' + udid, suffix: '.png' }));

      case 2:
        pathToScreenshotPng = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(simExec('io', 0, [udid, 'screenshot', pathToScreenshotPng]));

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(pathToScreenshotPng));

      case 7:
        screenshotImg = context$1$0.sent;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(pathToScreenshotPng));

      case 10:
        return context$1$0.abrupt('return', screenshotImg.toString('base64'));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Set the content of Simulator pasteboard (xcode >= 8.1 only).
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - Device UDID.
 * @param {string} content - The actual string content to be set.
 * @param {string} encoding ['utf-8'] - The encoding of the given pasteboard content.
 *                                      UTF-8 by default.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function setPasteboard(udid, content) {
  var encoding = arguments.length <= 2 || arguments[2] === undefined ? 'utf-8' : arguments[2];
  var pbCopySubprocess, exitCodeVerifier, stdin;
  return _regeneratorRuntime.async(function setPasteboard$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        pbCopySubprocess = new _teen_process.SubProcess('xcrun', ['simctl', 'pbcopy', udid]);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(pbCopySubprocess.start(0));

      case 3:
        exitCodeVerifier = pbCopySubprocess.join();
        stdin = pbCopySubprocess.proc.stdin;

        stdin.setEncoding(encoding);
        stdin.write(content);
        stdin.end();
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(exitCodeVerifier);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Get the content of Simulator pasteboard (xcode >= 8.1 only).
 * It is required that Simulator is in _booted_ state.
 *
 * @param {string} udid - Device UDID.
 * @param {string} encoding ['utf-8'] - The encoding of the returned pasteboard content.
 *                                      UTF-8 by default.
 * @return {string} Current content of Simulator pasteboard or an empty string.
 * @throws {Error} If the corresponding simctl subcommand command
 *                 returns non-zero return code.
 */
function getPasteboard(udid) {
  var encoding = arguments.length <= 1 || arguments[1] === undefined ? 'utf-8' : arguments[1];

  var args, _ref6, stdout;

  return _regeneratorRuntime.async(function getPasteboard$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['simctl', 'pbpaste', udid];
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', args, { timeout: 0, encoding: encoding }));

      case 4:
        _ref6 = context$1$0.sent;
        stdout = _ref6.stdout;
        return context$1$0.abrupt('return', stdout);

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](1);

        if (context$1$0.t0.stderr) {
          log.errorAndThrow('Error running \'xcrun ' + args.join(' ') + '\': ' + context$1$0.t0.stderr.trim());
        } else {
          log.errorAndThrow(context$1$0.t0);
        }

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 9]]);
}

/**
 * Get the list of device types available in the current Xcode installation
 *
 * @return {Array<string>} List of the types of devices available
 * @throws {Error} If the corresponding simctl command fails
 */
function getDeviceTypes() {
  var _ref7, stdout, deviceTypes, msg;

  return _regeneratorRuntime.async(function getDeviceTypes$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(simExec('list', 0, ['devicetypes', '-j']));

      case 3:
        _ref7 = context$1$0.sent;
        stdout = _ref7.stdout;
        deviceTypes = JSON.parse(stdout.trim());
        return context$1$0.abrupt('return', deviceTypes.devicetypes.map(function (type) {
          return type.name;
        }));

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);
        msg = 'Unable to get list of device types: ' + context$1$0.t0.message;

        if (context$1$0.t0.stderr) {
          msg = msg + '. Stderr: ' + context$1$0.t0.stderr;
        }
        throw new Error(msg);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
}

exports.installApp = installApp;
exports.removeApp = removeApp;
exports.launch = launch;
exports.spawn = spawn;
exports.spawnSubProcess = spawnSubProcess;
exports.openUrl = openUrl;
exports.terminate = terminate;
exports.shutdown = shutdown;
exports.createDevice = createDevice;
exports.getAppContainer = getAppContainer;
exports.getScreenshot = getScreenshot;
exports.deleteDevice = deleteDevice;
exports.eraseDevice = eraseDevice;
exports.getDevices = getDevices;
exports.getRuntimeForPlatformVersion = getRuntimeForPlatformVersion;
exports.bootDevice = bootDevice;
exports.setPasteboard = setPasteboard;
exports.getPasteboard = getPasteboard;
exports.addMedia = addMedia;
exports.appInfo = appInfo;
exports.getDeviceTypes = getDeviceTypes;

// if we don't want to see the errors, just throw and allow the calling
// code do what it wants

// first make sure that the runtime id is the right one
// in some versions of Xcode it will be a patch version

// make sure that it gets out of the "Creating" state

// need to retry

// stop looking, we're done

// retry erase with a sleep in between because it's flakey

// expect to get a listing like
// -- iOS 8.1 --
//     iPhone 4s (3CA6E7DD-220E-45E5-B716-1E992B3A429C) (Shutdown)
//     ...
// -- iOS 8.2 --
//     iPhone 4s (A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E) (Shutdown)
//     ...
// so, get the `-- iOS X.X --` line to find the sdk (X.X)
// and the rest of the listing in order to later find the devices

// a line is something like
//    iPhone 4s (A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E) (Shutdown)
// retrieve:
//   iPhone 4s
//   A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E
//   Shutdown
// https://regex101.com/r/lG7mK6/3

// if a `forSdk` was passed in, return only the corresponding list

// otherwise return everything

// if nothing was found, pass platform version back

/*
 * JSON will be like:
 *   {
 *     "devicetypes" : [
 *       {
 *         "name" : "iPhone 4s",
 *         "identifier" : "com.apple.CoreSimulator.SimDeviceType.iPhone-4s"
 *       },
 *       ...
 *   }
 */
//# sourceMappingURL=data:application/json;charset=utf8;base64,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NUIsNEJBQTRCO1FBQ25FLFVBQVUsR0FBVixVQUFVO1FBQUUsYUFBYSxHQUFiLGFBQWE7UUFBRSxhQUFhLEdBQWIsYUFBYTtRQUFFLFFBQVEsR0FBUixRQUFRO1FBQUUsT0FBTyxHQUFQLE9BQU87UUFDM0QsY0FBYyxHQUFkLGNBQWMiLCJmaWxlIjoibGliL3NpbWN0bC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCB7IGxvZ2dlciwgZnMsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ3NpbWN0bCcpO1xuXG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL1V5a2pRWi8xXG5jb25zdCBJT1NfUlVOVElNRV9SRUdFWFAgPSAvaU9TIChcXGQrXFwuXFxkKykgXFwoKFxcZCtcXC5cXGQrXFwuKlxcZCopLztcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwYXJ0aWN1bGFyIHNpbWN0bCBjb21tYW5kIGFuZCByZXR1cm4gdGhlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIE9uZSBvZiBhdmFpbGFibGUgc2ltY3RsIHN1YmNvbW1hbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBFeGVjdXRlIGB4Y3J1biBzaW1jdGxgIGluIFRlcm1pbmFsIHRvIHNlZSB0aGUgZnVsbCBsaXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGF2YWlsYWJsZSBzdWJjb21tYW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gQ29tbWFuZCBleGVjdXRpb24gdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBpdCB0byB6ZXJvIHRvIHNraXAgd2FpdGluZyBmb3IgY29tbWFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBhcmdzIFtbXV0gLSBUaGUgbGlzdCBvZiBhZGRpdGlvbmFsIHN1YmNvbW1hbmQgYXJndW1lbnRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQncyBlbXB0eSBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtPYmplY3R9IGVudiBbe31dIC0gRW52aXJvbm1lbnQgdmFyaWFibGVzIG1hcHBpbmcuIEFsbCB0aGVzZSB2YXJpYWJsZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgcGFzc2VkIFNpbXVsYXRvciBhbmQgdXNlZCBpbiBfZXhlY3V0aW5nRnVuY3Rpb25fLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0aW5nRnVuY3Rpb24gLSBFeGVjdXRpbmcgZnVuY3Rpb24gb2JqZWN0LiBFcXVhbHMgdG8gdGVlbl9wcm9jZXNzJ3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4ZWNfIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ0Vycm9ycyBbdHJ1ZV0gLSBTZXQgaXQgdG8gX2ZhbHNlXyB0byB0aHJvdyBleGVjdXRpb24gZXJyb3JzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseSB3aXRob3V0IGxvZ2dpbmcgYW55IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHQgb2YgX2V4ZWN1dGluZ0Z1bmN0aW9uXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZCBleGVjdXRlZCBieSBfZXhlY3V0aW5nRnVuY3Rpb25fXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2ltQ29tbWFuZCAoY29tbWFuZCwgdGltZW91dCwgYXJncyA9IFtdLCBlbnYgPSB7fSwgZXhlY3V0aW5nRnVuY3Rpb24gPSBleGVjLCBsb2dFcnJvcnMgPSB0cnVlKSB7XG4gIC8vIHJ1biBhIHBhcnRpY3VsYXIgc2ltY3RsIGNvbW1hbmRcbiAgYXJncyA9IFsnc2ltY3RsJywgY29tbWFuZCwgLi4uYXJnc107XG4gIC8vIFByZWZpeCBhbGwgcGFzc2VkIGluIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoICdTSU1DVExfQ0hJTERfJywgc2ltY3RsXG4gIC8vIHdpbGwgdGhlbiBwYXNzIHRoZXNlIHRvIHRoZSBjaGlsZCAoc3Bhd25lZCkgcHJvY2Vzcy5cbiAgZW52ID0gXy5kZWZhdWx0cyhfLm1hcEtleXMoZW52LCAodmFsdWUsIGtleSkgPT4ge1xuICAgIHJldHVybiBgU0lNQ1RMX0NISUxEXyR7a2V5fWA7XG4gIH0pLCBwcm9jZXNzLmVudik7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXhlY3V0aW5nRnVuY3Rpb24oJ3hjcnVuJywgYXJncywge3RpbWVvdXQsIGVudn0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCFsb2dFcnJvcnMpIHtcbiAgICAgIC8vIGlmIHdlIGRvbid0IHdhbnQgdG8gc2VlIHRoZSBlcnJvcnMsIGp1c3QgdGhyb3cgYW5kIGFsbG93IHRoZSBjYWxsaW5nXG4gICAgICAvLyBjb2RlIGRvIHdoYXQgaXQgd2FudHNcbiAgICAgIHRocm93IGU7XG4gICAgfSBlbHNlIGlmIChlLnN0ZGVycikge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYHNpbWN0bCBlcnJvciBydW5uaW5nICcke2NvbW1hbmR9JzogJHtlLnN0ZGVyci50cmltKCl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV4ZWNSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gc3Rkb3V0IC0gUHJvY2VzcyBzdGRvdXQuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHN0ZGVyciAtIFByb2Nlc3Mgc3RkZXJyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSBQcm9jZXNzIGV4aXQgY29kZS5cbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHBhcnRpY3VsYXIgc2ltY3RsIHN1YmNvbW1hbmQgc3luY2hyb25vdXNseSBhbmRcbiAqIHdhaXQgZm9yIHRoZSBvdXRwdXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmQgLSBTZWUge0BsaW5rIHNpbUNvbW1hbmR9IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGFyZ3MgW1tdXSAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgW3t9XSAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9nRXJyb3JzIFt0cnVlXSAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge0V4ZWNSZXN1bHR9IFRoZSByZXN1bHQgb2YgX2V4ZWNfIGZ1bmN0aW9uLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kIGV4ZWN1dGVkIGJ5IGV4ZWNcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaW1FeGVjIChjb21tYW5kLCB0aW1lb3V0LCBhcmdzID0gW10sIGVudiA9IHt9LCBsb2dFcnJvcnMgPSB0cnVlKSB7XG4gIHJldHVybiBhd2FpdCBzaW1Db21tYW5kKGNvbW1hbmQsIHRpbWVvdXQsIGFyZ3MsIGVudiwgYXN5bmMgKGMsIGEsIG9iKSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IGV4ZWMoYywgYSwgb2IpO1xuICB9LCBsb2dFcnJvcnMpO1xufVxuXG4vKipcbiAqIENyYXRlIGEgdGVlbl9wcm9jZXNzJ3MgU3ViUHJvY2VzcyBpbnN0YW5jZSBmb3IgdGhlIHBhcnRpY3VsYXJcbiAqIHNpbWN0bCBzdWJjb21tYW5kIGV4ZWN1dGlvbi4gVGhpcyBtaWdodCBiZSBuZWVkZWQgdG8gZ2FpbiBiZXR0ZXJcbiAqIGNvbnRyb2wgb3ZlciB0aGUgZXhlY3V0aW9uIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmQgLSBTZWUge0BsaW5rIHNpbUNvbW1hbmR9IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGFyZ3MgW1tdXSAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgW3t9XSAtIFNlZSB7QGxpbmsgc2ltQ29tbWFuZH0gcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge1N1YlByb2Nlc3N9IFRoZSBpbnN0YW5jZSBvZiB0ZWVuX3Byb2Nlc3MncyBTdWJQcm9jZXNzIGNsYXNzLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaW1TdWJQcm9jZXNzIChjb21tYW5kLCB0aW1lb3V0LCBhcmdzID0gW10sIGVudiA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBzaW1Db21tYW5kKGNvbW1hbmQsIHRpbWVvdXQsIGFyZ3MsIGVudiwgYXN5bmMgKGMsIGEsIG9iKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTdWJQcm9jZXNzKGMsIGEsIG9iKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zdGFsbCB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvbiBwYWNrYWdlIG9uIFNpbXVsYXRvci5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcFBhdGggLSBGdWxsIHBhdGggdG8gLmFwcCBwYWNrYWdlLCB3aGljaCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBnb2luZyB0byBiZSBpbnN0YWxsZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxBcHAgKHVkaWQsIGFwcFBhdGgpIHtcbiAgYXdhaXQgc2ltRXhlYygnaW5zdGFsbCcsIDAsIFt1ZGlkLCBhcHBQYXRoXSk7XG59XG5cbi8qKlxuICogQm9vdCB0aGUgcGFydGljdWxhciBTaW11bGF0b3IgaWYgaXQgaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJvb3REZXZpY2UgKHVkaWQpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzaW1FeGVjKCdib290JywgMCwgW3VkaWRdKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKChlcnIubWVzc2FnZSB8fCAnJykuaW5kZXhPZignVW5hYmxlIHRvIGJvb3QgZGV2aWNlIGluIGN1cnJlbnQgc3RhdGU6IEJvb3RlZCcpID09PSAtMSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYFNpbXVsYXRvciBhbHJlYWR5IGluICdCb290ZWQnIHN0YXRlLiBDb250aW51aW5nYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gcGFja2FnZSBmcm9tIFNpbXVsYXRvci5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlIGFuZFxuICogdGhlIGFwcGxpY2F0aW9uIHdpdGggZ2l2ZW4gYnVuZGxlIGlkZW50aWZpZXIgaXMgYWxyZWFkeSBpbnN0YWxsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBCdW5kbGUgaWRlbnRpZmllciBvZiB0aGUgYXBwbGljYXRpb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBpcyBnb2luZyB0byBiZSByZW1vdmVkLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiByZW1vdmVBcHAgKHVkaWQsIGJ1bmRsZUlkKSB7XG4gIGF3YWl0IHNpbUV4ZWMoJ3VuaW5zdGFsbCcsIDAsIFt1ZGlkLCBidW5kbGVJZF0pO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gcGFja2FnZSBvbiBTaW11bGF0b3IuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZSBhbmRcbiAqIHRoZSBhcHBsaWNhdGlvbiB3aXRoIGdpdmVuIGJ1bmRsZSBpZGVudGlmaWVyIGlzIGFscmVhZHkgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gQnVuZGxlIGlkZW50aWZpZXIgb2YgdGhlIGFwcGxpY2F0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggaXMgZ29pbmcgdG8gYmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0cmllcyBbNV0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyBiZWZvcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd2luZyBhbiBleGNlcHRpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaCAodWRpZCwgYnVuZGxlSWQsIHRyaWVzID0gNSkge1xuICBhd2FpdCByZXRyeUludGVydmFsKHRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgc2ltRXhlYygnbGF1bmNoJywgMCwgW3VkaWQsIGJ1bmRsZUlkXSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNwYXduIHRoZSBwYXJ0aWN1bGFyIHByb2Nlc3Mgb24gU2ltdWxhdG9yLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhlY3V0YWJsZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgcHJvY2VzcyBvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWwgU2ltdWxhdG9yIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtvYmplY3R9IGVudiBbe31dIC0gQWRkaXRpb25hbCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgbWFwcGluZy5cbiAqIEByZXR1cm4ge0V4ZWNSZXN1bHR9IENvbW1hbmQgZXhlY3V0aW9uIHJlc3VsdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3Bhd24gKHVkaWQsIGV4ZWN1dGFibGVQYXRoLCBlbnYgPSB7fSkge1xuICByZXR1cm4gYXdhaXQgc2ltRXhlYygnc3Bhd24nLCAwLCBbdWRpZCwgZXhlY3V0YWJsZVBhdGhdLCBlbnYpO1xufVxuXG4vKipcbiAqIFByZXBhcmUgU3ViUHJvY2VzcyBpbnN0YW5jZSBmb3IgYSBuZXcgcHJvY2Vzcywgd2hpY2ggaXMgZ29pbmcgdG8gYmUgc3Bhd25lZFxuICogb24gU2ltdWxhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4ZWN1dGFibGVQYXRoIC0gVGhlIHBhdGggdG8gdGhlIHByb2Nlc3Mgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsIFNpbXVsYXRvciBmaWxlIHN5c3RlbS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgW3t9XSAtIEFkZGl0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGVzIG1hcHBpbmcuXG4gKiBAcmV0dXJuIHtTdWJQcm9jZXNzfSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHByb2Nlc3MgdG8gYmUgc3Bhd25lZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3Bhd25TdWJQcm9jZXNzICh1ZGlkLCBleGVjdXRhYmxlUGF0aCwgZW52ID0ge30pIHtcbiAgcmV0dXJuIGF3YWl0IHNpbVN1YlByb2Nlc3MoJ3NwYXduJywgMCwgW3VkaWQsIGV4ZWN1dGFibGVQYXRoXSwgZW52KTtcbn1cblxuLyoqXG4gKiBPcGVuIFVSTCBzY2hlbWUgb24gU2ltdWxhdG9yLiBpT1Mgd2lsbCBhdXRvbWF0aWNhbGx5IHRyeVxuICogdG8gZmluZCBhIG1hdGNoaW5nIGFwcGxpY2F0aW9uLCB3aGljaCBzdXBwb3J0cyB0aGUgZ2l2ZW4gc2NoZW1lLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBzY2hlbWUgdG8gb3BlbiwgZm9yIGV4YW1wbGUgaHR0cDovL2FwcGlvbS5pb1xuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgb3BlbmVkIGJ5IHRoZSBidWlsdC1pbiBtb2JpbGUgYnJvd3Nlci5cbiAqIEByZXR1cm4ge0V4ZWNSZXN1bHR9IENvbW1hbmQgZXhlY3V0aW9uIHJlc3VsdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gb3BlblVybCAodWRpZCwgdXJsKSB7XG4gIHJldHVybiBhd2FpdCBzaW1FeGVjKCdvcGVudXJsJywgMCwgW3VkaWQsIHVybF0pO1xufVxuXG4vKipcbiAqIEludm9rZSBoaWRkZW4gYXBwaW5mbyBzdWJjb21tYW5kIHRvIGdldCB0aGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IGFwcGxpY2F0aW9ucyBpbnN0YWxsZWQgb24gU2ltdWxhdG9yLCBpbmNsdWRpbmdcbiAqIHN5c3RlbSBhcHBsaWNhdGlvbnMgKHtAbGluayBnZXRBcHBDb250YWluZXJ9IGRvZXMgbm90IFwic2VlXCIgc3VjaCBhcHBzKS5cbiAqIFNpbXVsYXRvciBzZXJ2ZXIgc2hvdWxkIGJlIGluICdib290ZWQnIHN0YXRlIGZvciB0aGlzIGNhbGwgdG8gd29yayBwcm9wZXJseS5cbiAqIFRoZSB0b29sIGlzIG9ubHkgYXZhaWxhYmxlIHNpbmNlIFhjb2RlIFNESyA4LjFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFVESUQgb2YgdGhlIHRhcmdldCBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgYnVuZGxlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCBhcHBsaWNhdGlvbi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGluZm9ybWF0aW9uIGFib3V0IGluc3RhbGxlZCBhcHBsaWNhdGlvbi5cbiAqXG4gKiBFeGFtcGxlIG91dHB1dCBmb3Igbm9uLWV4aXN0aW5nIGFwcGxpY2F0aW9uIGNvbnRhaW5lcjpcbiAqIDxwcmU+XG4gKiB7XG4gKiAgIENGQnVuZGxlSWRlbnRpZmllciA9IFwiY29tLmFwcGxlLk1vYmlsZVNhZmFyaVwiO1xuICogICBHcm91cENvbnRhaW5lcnMgPSAgICAge1xuICogICB9O1xuICogICBTQkFwcFRhZ3MgPSAgICAgKFxuICogICApO1xuICogfVxuICogPC9wcmU+XG4gKlxuICogRXhhbXBsZSBvdXRwdXQgZm9yIGFuIGV4aXN0aW5nIHN5c3RlbSBhcHBsaWNhdGlvbiBjb250YWluZXI6XG4gKiA8cHJlPlxuICoge1xuICogICBBcHBsaWNhdGlvblR5cGUgPSBIaWRkZW47XG4gKiAgIEJ1bmRsZSA9IFwiZmlsZTovLy9BcHBsaWNhdGlvbnMvWGNvZGUtYmV0YS5hcHAvQ29udGVudHMvRGV2ZWxvcGVyL1BsYXRmb3Jtcy9pUGhvbmVPUy5wbGF0Zm9ybS9EZXZlbG9wZXIvTGlicmFyeS9Db3JlU2ltdWxhdG9yL1Byb2ZpbGVzL1J1bnRpbWVzL2lPUy5zaW1ydW50aW1lL0NvbnRlbnRzL1Jlc291cmNlcy9SdW50aW1lUm9vdC9TeXN0ZW0vTGlicmFyeS9Db3JlU2VydmljZXMvU3ByaW5nQm9hcmQuYXBwXCI7XG4gKiAgIENGQnVuZGxlRGlzcGxheU5hbWUgPSBTcHJpbmdCb2FyZDtcbiAqICAgQ0ZCdW5kbGVFeGVjdXRhYmxlID0gU3ByaW5nQm9hcmQ7XG4gKiAgIENGQnVuZGxlSWRlbnRpZmllciA9IFwiY29tLmFwcGxlLnNwcmluZ2JvYXJkXCI7XG4gKiAgIENGQnVuZGxlTmFtZSA9IFNwcmluZ0JvYXJkO1xuICogICBDRkJ1bmRsZVZlcnNpb24gPSA1MDtcbiAqICAgR3JvdXBDb250YWluZXJzID0gICAgIHtcbiAqICAgfTtcbiAqICAgUGF0aCA9IFwiL0FwcGxpY2F0aW9ucy9YY29kZS1iZXRhLmFwcC9Db250ZW50cy9EZXZlbG9wZXIvUGxhdGZvcm1zL2lQaG9uZU9TLnBsYXRmb3JtL0RldmVsb3Blci9MaWJyYXJ5L0NvcmVTaW11bGF0b3IvUHJvZmlsZXMvUnVudGltZXMvaU9TLnNpbXJ1bnRpbWUvQ29udGVudHMvUmVzb3VyY2VzL1J1bnRpbWVSb290L1N5c3RlbS9MaWJyYXJ5L0NvcmVTZXJ2aWNlcy9TcHJpbmdCb2FyZC5hcHBcIjtcbiAqICAgU0JBcHBUYWdzID0gICAgIChcbiAqICAgKTtcbiAqIH1cbiAqIDwvcHJlPlxuICovXG5hc3luYyBmdW5jdGlvbiBhcHBJbmZvICh1ZGlkLCBidW5kbGVJZCkge1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHNpbUV4ZWMoJ2FwcGluZm8nLCAwLCBbdWRpZCwgYnVuZGxlSWRdKTtcbiAgcmV0dXJuIChzdGRvdXQgfHwgJycpLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBBZGQgdGhlIHBhcnRpY3VsYXIgbWVkaWEgZmlsZSB0byBTaW11bGF0b3IncyBsaWJyYXJ5LlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIEZ1bGwgcGF0aCB0byBhIG1lZGlhIGZpbGUgb24gdGhlIGxvY2FsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtLlxuICogQHJldHVybiB7RXhlY1Jlc3VsdH0gQ29tbWFuZCBleGVjdXRpb24gcmVzdWx0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBhZGRNZWRpYSAodWRpZCwgcGF0aCkge1xuICByZXR1cm4gYXdhaXQgc2ltRXhlYygnYWRkbWVkaWEnLCAwLCBbdWRpZCwgcGF0aF0pO1xufVxuXG4vKipcbiAqIFRlcm1pbmF0ZSB0aGUgZ2l2ZW4gcnVubmluZyBhcHBsaWNhdGlvbiBvbiBTaW11bGF0b3IuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZCAtIEJ1bmRsZSBpZGVudGlmaWVyIG9mIHRoZSBhcHBsaWNhdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGlzIGdvaW5nIHRvIGJlIHRlcm1pbmF0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRlcm1pbmF0ZSAodWRpZCwgYnVuZGxlSWQpIHtcbiAgYXdhaXQgc2ltRXhlYygndGVybWluYXRlJywgMCwgW3VkaWQsIGJ1bmRsZUlkXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmdWxsIHBhdGggdG8gdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gY29udGFpbmVyXG4gKiBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uIE5vdGUsIHRoYXQgdGhpcyBzdWJjb21tYW5kIHRocm93c1xuICogYW4gZXJyb3IgaWYgYnVuZGxlIGlkIG9mIGEgc3lzdGVtIGFwcGxpY2F0aW9uIGlzIHByb3ZpZGVkLFxuICogbGlrZSAnY29tLmFwcGxlLnNwcmluZ2JvYXJkJy5cbiAqIEl0IGlzIHJlcXVpcmVkIHRoYXQgU2ltdWxhdG9yIGlzIGluIF9ib290ZWRfIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gQnVuZGxlIGlkZW50aWZpZXIgb2YgYW4gYXBwbGljYXRpb24uXG4gKiBAcGFyYW0gez9ib29sZWFufSBsb2dFcnJvcnMgW3RydWVdIC0gV2hldGhlciB0byBpbmNsdWRlIGV4ZWMncyBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyIG91dHB1dCBpbnRvIGV4Y2VwdGlvbiBtZXNzYWdlIGlmIHRocm93bi5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY29udGFpbmVyVHlwZSAtIFdoaWNoIGNvbnRhaW5lciB0eXBlIHRvIHJldHVybi4gUG9zc2libGUgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYXBwJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb24gdGhlIGxvY2FsXG4gKiAgICAgICAgICAgICAgICAgIGZpbGUgc3lzdGVtLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBcHBDb250YWluZXIgKHVkaWQsIGJ1bmRsZUlkLCBsb2dFcnJvcnMgPSB0cnVlLCBjb250YWluZXJUeXBlID0gbnVsbCkge1xuICBjb25zdCBhcmdzID0gW3VkaWQsIGJ1bmRsZUlkXTtcbiAgaWYgKGNvbnRhaW5lclR5cGUpIHtcbiAgICBhcmdzLnB1c2goY29udGFpbmVyVHlwZSk7XG4gIH1cbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBzaW1FeGVjKCdnZXRfYXBwX2NvbnRhaW5lcicsIDAsIGFyZ3MsIHt9LCBsb2dFcnJvcnMpO1xuICByZXR1cm4gKHN0ZG91dCB8fCAnJykudHJpbSgpO1xufVxuXG4vKipcbiAqIFNodXRkb3duIHRoZSBnaXZlbiBTaW11bGF0b3IgaWYgaXQgaXMgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2h1dGRvd24gKHVkaWQpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzaW1FeGVjKCdzaHV0ZG93bicsIDAsIFt1ZGlkXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghKGVyciArICcnKS5pbmNsdWRlcygnY3VycmVudCBzdGF0ZTogU2h1dGRvd24nKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYFNpbXVsYXRvciBhbHJlYWR5IGluICdTaHV0ZG93bicgc3RhdGUuIENvbnRpbnVpbmdgKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBTaW11bGF0b3IgZGV2aWNlIHdpdGggZ2l2ZW4gbmFtZSBmb3IgdGhlIHBhcnRpY3VsYXJcbiAqIHBsYXRmb3JtIHR5cGUgYW5kIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGV2aWNlIG5hbWUgdG8gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VUeXBlSWQgLSBEZXZpY2UgdHlwZSwgZm9yIGV4YW1wbGUgJ2lQaG9uZSA2Jy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBydW50aW1lSWQgLSBQbGF0Zm9ybSB2ZXJzaW9uLCBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBbMTAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdCBkZXZpY2UgY3JlYXRpb24gaXMgY29tcGxldGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgVURJRCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBkZXZpY2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURldmljZSAobmFtZSwgZGV2aWNlVHlwZUlkLCBydW50aW1lSWQsIHRpbWVvdXQgPSAxMDAwMCkge1xuICBsZXQgdWRpZDtcbiAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIHJ1bnRpbWUgaWQgaXMgdGhlIHJpZ2h0IG9uZVxuICAvLyBpbiBzb21lIHZlcnNpb25zIG9mIFhjb2RlIGl0IHdpbGwgYmUgYSBwYXRjaCB2ZXJzaW9uXG4gIHRyeSB7XG4gICAgcnVudGltZUlkID0gYXdhaXQgZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbihydW50aW1lSWQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIGZpbmQgcnVudGltZSBmb3IgaU9TICcke3J1bnRpbWVJZH0nLiBDb250aW51aW5nYCk7XG4gIH1cblxuICBsb2cuZGVidWcoYENyZWF0aW5nIHNpbXVsYXRvciB3aXRoIG5hbWUgJyR7bmFtZX0nLCBkZXZpY2UgdHlwZSBpZCAnJHtkZXZpY2VUeXBlSWR9JyBhbmQgcnVudGltZSBpZCAnJHtydW50aW1lSWR9J2ApO1xuICB0cnkge1xuICAgIGxldCBvdXQgPSBhd2FpdCBzaW1FeGVjKCdjcmVhdGUnLCAwLCBbbmFtZSwgZGV2aWNlVHlwZUlkLCBydW50aW1lSWRdKTtcbiAgICB1ZGlkID0gb3V0LnN0ZG91dC50cmltKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxldCByZWFzb24gPSBlcnIubWVzc2FnZTtcbiAgICBpZiAoZXJyLnN0ZGVycikge1xuICAgICAgcmVhc29uID0gZXJyLnN0ZGVyci50cmltKCk7XG4gICAgfVxuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgY3JlYXRlIHNpbXVsYXRvciB3aXRoIG5hbWUgJyR7bmFtZX0nLCBkZXZpY2UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYHR5cGUgaWQgJyR7ZGV2aWNlVHlwZUlkfScgYW5kIHJ1bnRpbWUgaWQgJyR7cnVudGltZUlkfScuIFJlYXNvbjogJyR7cmVhc29ufSdgKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IGl0IGdldHMgb3V0IG9mIHRoZSBcIkNyZWF0aW5nXCIgc3RhdGVcbiAgbGV0IHJldHJpZXMgPSBwYXJzZUludCh0aW1lb3V0IC8gMTAwMCwgMTApO1xuICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcbiAgICBmb3IgKGxldCBkZXZpY2VBcnIgb2YgXy52YWx1ZXMoZGV2aWNlcykpIHtcbiAgICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VBcnIpIHtcbiAgICAgICAgaWYgKGRldmljZS51ZGlkID09PSB1ZGlkKSB7XG4gICAgICAgICAgaWYgKGRldmljZS5zdGF0ZSA9PT0gJ0NyZWF0aW5nJykge1xuICAgICAgICAgICAgLy8gbmVlZCB0byByZXRyeVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXZpY2Ugc3RpbGwgYmVpbmcgY3JlYXRlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9wIGxvb2tpbmcsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1ZGlkO1xufVxuXG4vKipcbiAqIERlbGV0ZSB0aGUgcGFydGljdWxhciBTaW11bGF0b3IgZnJvbSBhdmFpbGFibGUgZGV2aWNlcyBsaXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIFVESUQgb2YgYW4gZXhpc3RpbmcgU2ltdWxhdG9yLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVEZXZpY2UgKHVkaWQpIHtcbiAgYXdhaXQgc2ltRXhlYygnZGVsZXRlJywgMCwgW3VkaWRdKTtcbn1cblxuLyoqXG4gKiBSZXNldCB0aGUgY29udGVudCBhbmQgc2V0dGluZ3Mgb2YgdGhlIHBhcnRpY3VsYXIgU2ltdWxhdG9yLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX3NodXRkb3duXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBVRElEIG9mIGFuIGV4aXN0aW5nIFNpbXVsYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFsxMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0IGRldmljZSByZXNldCBpcyBjb21wbGV0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVyYXNlRGV2aWNlICh1ZGlkLCB0aW1lb3V0ID0gMTAwMCkge1xuICBsZXQgbG9vcEZuID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNpbUV4ZWMoJ2VyYXNlJywgMTAwMDAsIFt1ZGlkXSk7XG4gIH07XG4gIC8vIHJldHJ5IGVyYXNlIHdpdGggYSBzbGVlcCBpbiBiZXR3ZWVuIGJlY2F1c2UgaXQncyBmbGFrZXlcbiAgbGV0IHJldHJpZXMgPSBwYXJzZUludCh0aW1lb3V0IC8gMjAwLCAxMCk7XG4gIGF3YWl0IHJldHJ5SW50ZXJ2YWwocmV0cmllcywgMjAwLCBsb29wRm4pO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZUluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRldmljZSBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIFVESUQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBUaGUgY3VycmVudCBTaW11bGF0b3Igc3RhdGUsIGZvciBleGFtcGxlICdib290ZWQnIG9yICdzaHV0ZG93bicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2RrIC0gVGhlIFNESyB2ZXJzaW9uLCBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKi9cblxuLyoqXG4gKiBQYXJzZSB0aGUgbGlzdCBvZiBleGlzdGluZyBTaW11bGF0b3IgZGV2aWNlcyB0byByZXByZXNlbnRcbiAqIGl0IGFzIGNvbnZlbmllbnQgbWFwcGluZy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgbWFwcGluZy4gRWFjaCBrZXkgaXMgcGxhdGZvcm0gdmVyc2lvbixcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUgJzEwLjMnIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBpcyBhblxuICogICAgICAgICAgICAgICAgICBhcnJheSBvZiB0aGUgbWF0Y2hpbmcge0BsaW5rIERldmljZUluZm99IGluc3RhbmNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlc0J5UGFyc2luZyAoKSB7XG4gIC8vIGdldCB0aGUgbGlzdCBvZiBkZXZpY2VzXG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IHNpbUV4ZWMoJ2xpc3QnLCAwLCBbJ2RldmljZXMnXSk7XG5cbiAgLy8gZXhwZWN0IHRvIGdldCBhIGxpc3RpbmcgbGlrZVxuICAvLyAtLSBpT1MgOC4xIC0tXG4gIC8vICAgICBpUGhvbmUgNHMgKDNDQTZFN0RELTIyMEUtNDVFNS1CNzE2LTFFOTkyQjNBNDI5QykgKFNodXRkb3duKVxuICAvLyAgICAgLi4uXG4gIC8vIC0tIGlPUyA4LjIgLS1cbiAgLy8gICAgIGlQaG9uZSA0cyAoQTk5RkZGQzMtOEUxOS00RENGLUI1ODUtN0Q5RDQ2QjRDMTZFKSAoU2h1dGRvd24pXG4gIC8vICAgICAuLi5cbiAgLy8gc28sIGdldCB0aGUgYC0tIGlPUyBYLlggLS1gIGxpbmUgdG8gZmluZCB0aGUgc2RrIChYLlgpXG4gIC8vIGFuZCB0aGUgcmVzdCBvZiB0aGUgbGlzdGluZyBpbiBvcmRlciB0byBsYXRlciBmaW5kIHRoZSBkZXZpY2VzXG4gIGxldCBkZXZpY2VTZWN0aW9uUmUgPSAvLS0gaU9TICguKykgLS0oXFxuXFxzezR9LispKi9tZztcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgbGV0IG1hdGNoID0gZGV2aWNlU2VjdGlvblJlLmV4ZWMoc3Rkb3V0KTtcblxuICAvLyBtYWtlIGFuIGVudHJ5IGZvciBlYWNoIHNkayB2ZXJzaW9uXG4gIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgbWF0Y2ggPSBkZXZpY2VTZWN0aW9uUmUuZXhlYyhzdGRvdXQpO1xuICB9XG4gIGlmIChtYXRjaGVzLmxlbmd0aCA8IDEpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdygnQ291bGQgbm90IGZpbmQgZGV2aWNlIHNlY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGdldCBhbGwgdGhlIGRldmljZXMgZm9yIGVhY2ggc2RrXG4gIGxldCBkZXZpY2VzID0ge307XG4gIGZvciAobWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBzZGsgPSBtYXRjaFsxXTtcbiAgICBkZXZpY2VzW3Nka10gPSBbXTtcbiAgICAvLyBzcGxpdCB0aGUgZnVsbCBtYXRjaCBpbnRvIGxpbmVzIGFuZCByZW1vdmUgdGhlIGZpcnN0XG4gICAgZm9yIChsZXQgbGluZSBvZiBtYXRjaFswXS5zcGxpdCgnXFxuJykuc2xpY2UoMSkpIHtcbiAgICAgIC8vIGEgbGluZSBpcyBzb21ldGhpbmcgbGlrZVxuICAgICAgLy8gICAgaVBob25lIDRzIChBOTlGRkZDMy04RTE5LTREQ0YtQjU4NS03RDlENDZCNEMxNkUpIChTaHV0ZG93bilcbiAgICAgIC8vIHJldHJpZXZlOlxuICAgICAgLy8gICBpUGhvbmUgNHNcbiAgICAgIC8vICAgQTk5RkZGQzMtOEUxOS00RENGLUI1ODUtN0Q5RDQ2QjRDMTZFXG4gICAgICAvLyAgIFNodXRkb3duXG4gICAgICBsZXQgbGluZVJlID0gLyhbXlxcc10uKykgXFwoKFxcdystLitcXHcrKVxcKSBcXCgoXFx3K1xccz9cXHcrKVxcKS87IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvbEc3bUs2LzNcbiAgICAgIGxldCBsaW5lTWF0Y2ggPSBsaW5lUmUuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChsaW5lTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbWF0Y2ggbGluZTogJHtsaW5lfWApO1xuICAgICAgfVxuICAgICAgLy8gc2F2ZSB0aGUgd2hvbGUgdGhpbmcgYXMgYWIgb2JqZWN0IGluIHRoZSBsaXN0IGZvciB0aGlzIHNka1xuXG4gICAgICBkZXZpY2VzW3Nka10ucHVzaCh7XG4gICAgICAgIG5hbWU6IGxpbmVNYXRjaFsxXSxcbiAgICAgICAgdWRpZDogbGluZU1hdGNoWzJdLFxuICAgICAgICBzdGF0ZTogbGluZU1hdGNoWzNdLFxuICAgICAgICBzZGssXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGV2aWNlcztcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbGlzdCBvZiBleGlzdGluZyBTaW11bGF0b3IgZGV2aWNlcyB0byByZXByZXNlbnRcbiAqIGl0IGFzIGNvbnZlbmllbnQgbWFwcGluZyBmb3IgdGhlIHBhcnRpY3VsYXIgcGxhdGZvcm0gdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9yU2RrIFtudWxsXSAtIFRoZSBwbGF0Zm9ybSB2ZXJzaW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igd2hpY2ggdGhlIGRldmljZXMgbGlzdCBzaG91bGQgYmUgcGFyc2VkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXk8RGV2aWNlSW5mbz59IElmIF9mb3JTZGtfIGlzIHNldCB0aGVuIHRoZSBsaXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGRldmljZXMgZm9yIHRoZSBwYXJ0aWN1bGFyIHBsYXRmb3JtIHZlcnNpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSB0aGUgc2FtZSByZXN1bHQgYXMgZm9yIHtAbGluayBnZXREZXZpY2VzQnlQYXJzaW5nfVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZSBvciBpZiBubyBtYXRjaGluZ1xuICogICAgICAgICAgICAgICAgIHBsYXRmb3JtIHZlcnNpb24gaXMgZm91bmQgaW4gdGhlIHN5c3RlbS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlcyAoZm9yU2RrID0gbnVsbCkge1xuICBsZXQgZGV2aWNlcztcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBzaW1FeGVjKCdsaXN0JywgMCwgWydkZXZpY2VzJywgJy1qJ10pO1xuICAgIC8qIEpTT04gc2hvdWxkIGJlXG4gICAgICoge1xuICAgICAqICAgXCJkZXZpY2VzXCIgOiB7XG4gICAgICogICAgIFwiaU9TIDxzZGs+XCIgOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgXCJzdGF0ZVwiIDogXCJCb290ZWRcIixcbiAgICAgKiAgICAgICAgIFwiYXZhaWxhYmlsaXR5XCIgOiBcIihhdmFpbGFibGUpXCIsXG4gICAgICogICAgICAgICBcIm5hbWVcIiA6IFwiaVBob25lIDZcIixcbiAgICAgKiAgICAgICAgIFwidWRpZFwiIDogXCI3NUUzNDE0MC0xOEU4LTREMUEtOUY0NS1BQUM3MzVERjc1REZcIlxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkZXZpY2VzID0ge307XG4gICAgZm9yIChsZXQgW3Nka05hbWUsIGVudHJpZXNdICBvZiBfLnRvUGFpcnMoSlNPTi5wYXJzZShzdGRvdXQpLmRldmljZXMpKSB7XG4gICAgICBpZiAoc2RrTmFtZS5pbmRleE9mKCdpT1MnKSAhPT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBzZGsgPSBzZGtOYW1lLnJlcGxhY2UoJ2lPUyAnLCAnJyk7XG4gICAgICBkZXZpY2VzW3Nka10gPSBlbnRyaWVzLm1hcCgoZWwpID0+IHtcbiAgICAgICAgZGVsZXRlIGVsLmF2YWlsYWJpbGl0eTtcbiAgICAgICAgcmV0dXJuIHsuLi5lbCwgc2RrfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGBVbmFibGUgdG8gZ2V0IEpTT04gZGV2aWNlIGxpc3Q6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgbG9nLmRlYnVnKCdGYWxsaW5nIGJhY2sgdG8gbWFudWFsbHkgcGFyc2luZycpO1xuICAgIGRldmljZXMgPSBhd2FpdCBnZXREZXZpY2VzQnlQYXJzaW5nKCk7XG4gIH1cblxuICAvLyBpZiBhIGBmb3JTZGtgIHdhcyBwYXNzZWQgaW4sIHJldHVybiBvbmx5IHRoZSBjb3JyZXNwb25kaW5nIGxpc3RcbiAgaWYgKGZvclNkaykge1xuICAgIGlmICghZGV2aWNlc1tmb3JTZGtdKSB7XG4gICAgICBsZXQgZXJyTXNnID0gYCcke2ZvclNka30nIGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIHNpbWN0bCBTREtzLmA7XG4gICAgICBjb25zdCBhdmFpbGFibGVTREtzID0gXy5rZXlzKGRldmljZXMpO1xuICAgICAgZXJyTXNnICs9IGF2YWlsYWJsZVNES3MubGVuZ3RoID9cbiAgICAgICAgYCBPbmx5IHRoZSBmb2xsb3dpbmcgU2ltdWxhdG9yIFNESyB2ZXJzaW9ucyBhcmUgYXZhaWxhYmxlIG9uIHlvdXIgc3lzdGVtOiAke2F2YWlsYWJsZVNES3Muam9pbignLCAnKX1gIDpcbiAgICAgICAgYCBObyBTaW11bGF0b3IgU0RLIHZlcnNpb25zIGFyZSBhdmFpbGFibGUgb24geW91ciBzeXN0ZW0uIFBsZWFzZSBpbnN0YWxsIHNvbWUgdmlhIFhjb2RlIHByZWZlcmVuY2VzLmA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldmljZXNbZm9yU2RrXTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSByZXR1cm4gZXZlcnl0aGluZ1xuICByZXR1cm4gZGV2aWNlcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJ1bnRpbWUgZm9yIHRoZSBwYXJ0aWN1bGFyIHBsYXRmb3JtIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtVmVyc2lvbiAtIFRoZSBwbGF0Zm9ybSB2ZXJzaW9uIG5hbWUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUgJzEwLjMnLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29ycmVzcG9uZGluZyBydW50aW1lIG5hbWUgZm9yIHRoZSBnaXZlblxuICogICAgICAgICAgICAgICAgICBwbGF0Zm9ybSB2ZXJzaW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRm9yUGxhdGZvcm1WZXJzaW9uIChwbGF0Zm9ybVZlcnNpb24pIHtcbiAgdHJ5IHtcbiAgICAvLyBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y3J1bicsIFsnc2ltY3RsJywgJ2xpc3QnLCAncnVudGltZXMnXSk7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgc2ltRXhlYygnbGlzdCcsIDAsIFsncnVudGltZXMnXSk7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICBsZXQgbWF0Y2ggPSBJT1NfUlVOVElNRV9SRUdFWFAuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAobWF0Y2hbMV0gPT09IHBsYXRmb3JtVmVyc2lvbikge1xuICAgICAgICAgIHJldHVybiBtYXRjaFsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoaWduKSB7fVxuXG4gIC8vIGlmIG5vdGhpbmcgd2FzIGZvdW5kLCBwYXNzIHBsYXRmb3JtIHZlcnNpb24gYmFja1xuICByZXR1cm4gcGxhdGZvcm1WZXJzaW9uO1xufVxuXG4vKipcbiAqIEdldHMgYmFzZTY0IHNjcmVlbnNob3QgZm9yIGRldmljZSAoeGNvZGUgPj0gOC4xIG9ubHkpLlxuICogSXQgaXMgcmVxdWlyZWQgdGhhdCBTaW11bGF0b3IgaXMgaW4gX2Jvb3RlZF8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgVURJRCBvZiBhbiBleGlzdGluZyBTaW11bGF0b3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIFNpbXVsYXRvciBzY3JlZW5zaG90LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTY3JlZW5zaG90ICh1ZGlkKSB7XG4gIGxldCBwYXRoVG9TY3JlZW5zaG90UG5nID0gYXdhaXQgdGVtcERpci5wYXRoKHtwcmVmaXg6IGBzY3JlZW5zaG90LSR7dWRpZH1gLCBzdWZmaXg6ICcucG5nJ30pO1xuICBhd2FpdCBzaW1FeGVjKCdpbycsIDAsIFt1ZGlkLCAnc2NyZWVuc2hvdCcsIHBhdGhUb1NjcmVlbnNob3RQbmddKTtcbiAgbGV0IHNjcmVlbnNob3RJbWcgPSBhd2FpdCBmcy5yZWFkRmlsZShwYXRoVG9TY3JlZW5zaG90UG5nKTtcbiAgYXdhaXQgZnMucmltcmFmKHBhdGhUb1NjcmVlbnNob3RQbmcpO1xuICByZXR1cm4gc2NyZWVuc2hvdEltZy50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb250ZW50IG9mIFNpbXVsYXRvciBwYXN0ZWJvYXJkICh4Y29kZSA+PSA4LjEgb25seSkuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIERldmljZSBVRElELlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBUaGUgYWN0dWFsIHN0cmluZyBjb250ZW50IHRvIGJlIHNldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBbJ3V0Zi04J10gLSBUaGUgZW5jb2Rpbmcgb2YgdGhlIGdpdmVuIHBhc3RlYm9hcmQgY29udGVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVVEYtOCBieSBkZWZhdWx0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRQYXN0ZWJvYXJkICh1ZGlkLCBjb250ZW50LCBlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgY29uc3QgcGJDb3B5U3VicHJvY2VzcyA9IG5ldyBTdWJQcm9jZXNzKCd4Y3J1bicsIFsnc2ltY3RsJywgJ3BiY29weScsIHVkaWRdKTtcbiAgYXdhaXQgcGJDb3B5U3VicHJvY2Vzcy5zdGFydCgwKTtcbiAgY29uc3QgZXhpdENvZGVWZXJpZmllciA9IHBiQ29weVN1YnByb2Nlc3Muam9pbigpO1xuICBjb25zdCBzdGRpbiA9IHBiQ29weVN1YnByb2Nlc3MucHJvYy5zdGRpbjtcbiAgc3RkaW4uc2V0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzdGRpbi53cml0ZShjb250ZW50KTtcbiAgc3RkaW4uZW5kKCk7XG4gIGF3YWl0IGV4aXRDb2RlVmVyaWZpZXI7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIFNpbXVsYXRvciBwYXN0ZWJvYXJkICh4Y29kZSA+PSA4LjEgb25seSkuXG4gKiBJdCBpcyByZXF1aXJlZCB0aGF0IFNpbXVsYXRvciBpcyBpbiBfYm9vdGVkXyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIERldmljZSBVRElELlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFsndXRmLTgnXSAtIFRoZSBlbmNvZGluZyBvZiB0aGUgcmV0dXJuZWQgcGFzdGVib2FyZCBjb250ZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVURi04IGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgY29udGVudCBvZiBTaW11bGF0b3IgcGFzdGVib2FyZCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBhc3RlYm9hcmQgKHVkaWQsIGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICBjb25zdCBhcmdzID0gWydzaW1jdGwnLCAncGJwYXN0ZScsIHVkaWRdO1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygneGNydW4nLCBhcmdzLCB7dGltZW91dDogMCwgZW5jb2Rpbmd9KTtcbiAgICByZXR1cm4gc3Rkb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuc3RkZXJyKSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgcnVubmluZyAneGNydW4gJHthcmdzLmpvaW4oJyAnKX0nOiAke2Uuc3RkZXJyLnRyaW0oKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGRldmljZSB0eXBlcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgWGNvZGUgaW5zdGFsbGF0aW9uXG4gKlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gTGlzdCBvZiB0aGUgdHlwZXMgb2YgZGV2aWNlcyBhdmFpbGFibGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgY29tbWFuZCBmYWlsc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXREZXZpY2VUeXBlcyAoKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBzaW1FeGVjKCdsaXN0JywgMCwgWydkZXZpY2V0eXBlcycsICctaiddKTtcbiAgICAvKlxuICAgICAqIEpTT04gd2lsbCBiZSBsaWtlOlxuICAgICAqICAge1xuICAgICAqICAgICBcImRldmljZXR5cGVzXCIgOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgXCJuYW1lXCIgOiBcImlQaG9uZSA0c1wiLFxuICAgICAqICAgICAgICAgXCJpZGVudGlmaWVyXCIgOiBcImNvbS5hcHBsZS5Db3JlU2ltdWxhdG9yLlNpbURldmljZVR5cGUuaVBob25lLTRzXCJcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgfVxuICAgICAqL1xuICAgIGNvbnN0IGRldmljZVR5cGVzID0gSlNPTi5wYXJzZShzdGRvdXQudHJpbSgpKTtcbiAgICByZXR1cm4gZGV2aWNlVHlwZXMuZGV2aWNldHlwZXMubWFwKCh0eXBlKSA9PiB0eXBlLm5hbWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsZXQgbXNnID0gYFVuYWJsZSB0byBnZXQgbGlzdCBvZiBkZXZpY2UgdHlwZXM6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICBpZiAoZXJyLnN0ZGVycikge1xuICAgICAgbXNnID0gYCR7bXNnfS4gU3RkZXJyOiAke2Vyci5zdGRlcnJ9YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cblxuXG5leHBvcnQgeyBpbnN0YWxsQXBwLCByZW1vdmVBcHAsIGxhdW5jaCwgc3Bhd24sIHNwYXduU3ViUHJvY2Vzcywgb3BlblVybCxcbiAgICAgICAgIHRlcm1pbmF0ZSwgc2h1dGRvd24sIGNyZWF0ZURldmljZSwgZ2V0QXBwQ29udGFpbmVyLCBnZXRTY3JlZW5zaG90LFxuICAgICAgICAgZGVsZXRlRGV2aWNlLCBlcmFzZURldmljZSwgZ2V0RGV2aWNlcywgZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbixcbiAgICAgICAgIGJvb3REZXZpY2UsIHNldFBhc3RlYm9hcmQsIGdldFBhc3RlYm9hcmQsIGFkZE1lZGlhLCBhcHBJbmZvLFxuICAgICAgICAgZ2V0RGV2aWNlVHlwZXMgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
